---
layout : single
title : " Recursive, Selection"
categories: Baekjoon
tag: [python]
---

# 10872
<a href = "https://www.acmicpc.net/problem/10872">https://www.acmicpc.net/problem/10872</a>

```python
def factorial(n): return 1 if n==0 else n*factorial(n-1)
print(factorial(int(input())))
```


# 17478
<a href = "https://www.acmicpc.net/problem/17478">https://www.acmicpc.net/problem/17478</a>

```python
def prt(n,cnt):
    dash = '____'*cnt
    li = ['"재귀함수가 뭔가요?"','"잘 들어보게. 옛날옛날 한 산 꼭대기에 이세상 모든 지식을 통달한 선인이 있었어.','마을 사람들은 모두 그 선인에게 수많은 질문을 했고, 모두 지혜롭게 대답해 주었지.','그의 답은 대부분 옳았다고 하네. 그런데 어느 날, 그 선인에게 한 선비가 찾아와서 물었어."']
    a = '"재귀함수는 자기 자신을 호출하는 함수라네"'
    b = '라고 답변하였지.'
    if n == 0: print(dash+li[0]);print(dash+a);print(dash+b);return
    for i in li: print(dash+i)
    prt(n-1, cnt+1); print(dash+b)

print("어느 한 컴퓨터공학과 학생이 유명한 교수님을 찾아가 물었다.")
prt(int(input()), 0)

```


# 11004
<a href = "https://www.acmicpc.net/problem/11004">https://www.acmicpc.net/problem/11004</a>

```python
import random, sys
random.seed(42)
input = sys.stdin.readline
def QuickSelect(A, k):
    s, m, l = [], [], []; 
    pivot = A[random.randint(0,len(A)-1)]
    for i in A:
        if i<pivot: s.append(i)
        elif i == pivot: m.append(i)
        else: l.append(i)
    if len(s)>=k: return QuickSelect(s,k)
    elif len(s)+len(m) < k: return QuickSelect(l,k-len(s)-len(m))
    else: return pivot

n,k = map(int, input().split())
li = list(map(int, input().split()))
print(QuickSelect(li,k))
```
## problem 1 : 메모리 초과, 시간 +

기존 quickselect 이용 시 메모리 초과

## soltion

quickselect에서 피봇을 설정할 때 0번째 요소가 아닌, random으로 설정하도록 하여 해결



# 11729
<a href = "https://www.acmicpc.net/problem/11729">https://www.acmicpc.net/problem/11729</a>

```python
def hanoi(n, first, second, third):
    if n == 1: print(first, third); return
    else:
        hanoi(n-1, first, third, second)
        print(first, third)
        hanoi(n-1, second, first, third)

n = int(input())
print((2**n)-1)
hanoi(n, 1, 2, 3)
```

## problem 1 : 문제 해석 오류, 시간 초과 

모든 요소에 i = N-i+1 연산을 진행하는 것으로 착각하였으나, 필요한 요소만  i = N-i+1 연산을 해주면 된다.
모든 i는 i와 N-i+1 두 가지 값만 가질 수 있기 때문에 (*(N-(N-i+1)+1)=i) 해결 될 리 없었다. 매 단계마다 모든 요소의 크기를 바꿔주기 때문에 시간 초과도 따라옴

## soltion

1~N의 숫자 중 중간값을 찾아 mid로 정의하고, mid보다 앞에 있는 원소들은 i와 N-i+1 중 min을, 뒤에 있는 원소들은 max를 취하도록 하였다. 시간초과를 해결하기 위해, 한 단계가 진행될 때마다 전 원소와 크기를 비교하여 올바르지 않은 크기 순서가 나타날 경우 바로 return 0을 진행하였다.



