---
layout : single
title : " 9020 골드바흐의 추측"
categories: Baekjoon
tag: [python]
---

<a href = "https://www.acmicpc.net/problem/9020">https://www.acmicpc.net/problem/9020</a>

```python
import sys
input = sys.stdin.readline

def isPrime(num):
    if num == 2: return 1
    else:
        for i in range(2, int(num**0.5)+1):
            if num % i == 0: return False
        return True

for _ in range(int(input())):
    num1 = int(input())//2; num2 = num1;
    while 1:
        if isPrime(num1) and isPrime(num2): print(num1, num2); break;
        else: num1 -= 1; num2 += 1;

```
## point 1
가장 큰 수일 때 BIGGEST를 출력하기 위해, 문자열로 입력을 받은 후 리스트로 변환하고, 이를 reverse로 정렬한 결과가 입력과 같으면 BIGGEST를 출력하도록 한다.

## point 2
입력과 구성이 같으면서 입력보다 큰 수 중 가장 작은 수를 구하려면, 입력의 가장 아랫자리수부터 숫자를 바꿔주어야 한다. 따라서, 원하는대로 정렬이 가능한 가장 아랫자리가 어디인 지를 구해야 한다.

## soltion
<img src="/images/2022-06-22-2697/sol.jpg">
279134399742 를 예로 들면, 99742는 이미 내림차순으로 정렬되어 있는 부분이므로, 지금보다 더 큰 숫자를 만들 수 없다. 따라서, 아랫자리부터 검사하여 오름차순이 끊기는 자리인 279134**3**99742이 기준이 된다. 

```python
# 슬라이싱 된 리스트에서 3보다 큰 수만 뽑기
larger=[i for i in temp if i>num[target]] 
# 그 중 가장 작은 수를 찾아 슬라이싱 된 리스트에서 삭제
larger.sort(); temp.remove(larger[0]); 
# 변하지 않은 숫자 + 삭제한 수 + 슬라이싱 & 정렬 된 리스트
print(*(num[:target]+larger[:1]+sorted(temp)), sep="") 
```



