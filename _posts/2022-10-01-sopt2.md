---
layout : single
title : "[SOPT] 31기 IN SOPT 서버파트 1차 세미나"
categories: sopt
tag: []
sidebar:
    nav: "docs"
---

# 1차 세미나

- [x] [JavaScript](#javascript)
- [ ] [TypeScript](#typescript)
- [ ] [Node.js](#nodejs)

---

대부분 면접 준비하면서 공부했던 개념들이라 방대한 양에 비해 복잡하거나 어렵게 다가오지는 않았다. JS, TS, Node.js 모두 제대로 다뤄봤다고 말하긴 어렵지만 지겹도록 코드를 봤던 경험과, 최근 Node, Nest 벼락치기 하면서 손에 익은 것들이 꽤나 도움이 됐던 것 같다. 그러나 모든 게 처음인 사람이라면 버거웠을 양이라고 생각하기에 한 명이라도 읽지 않을까 하는 생각으로 정리해본다

저작권상 문제가 될 수 있으니 최대한 파트장님 자료에서는 목차만 참고하고 나의 지식을 끌어모아 적는 것으로 !

## JavaScript

### var, let, const

var, let, const 는 모두 javascript의 변수 선언 방식이다. 왜 세가지나 있냐 라고 한다면 기존에 있던 var 선언방식이 문제가 많아 ES6 버전 이후, let과 const가 등장했다

간단하게 각각의 특징을 정리해보자면 아래 표와 같다

|변수 선언 방식|특징|
|:---:|:---|
|var|1. 재선언(동일한 이름으로 변수 중복 생성) 가능<br>2. 재할당 (기존에 선언된 변수에 새로운 값을 할당) 가능<br>3. 함수 스코프<br>4. 호이스팅 O|
|let|1. 재선언 불가능<br>2. 재할당 가능<br>3. 블록 스코프<br>4. 호이스팅 X|
|const|1. 재선언 불가능<br>2. 재할당 가능<br>3. 블록 스코프<br>4. 호이스팅 X|

#### 재선언

재선언이 문제가 되는 이유는 변수명이 고유할 수록 코드가 안전해지기 때문이다. 사실 짧은 코드를 작성할 때에는 크게 문제가 되지 않는데 예를 들어

```javascript
var a = 1;
console.log(a); // 1

var a = 2;
console.log(a); // 2
```

와 같은 코드를 실행 했을 때 1과 2가 순서대로 출력될 것이라는 것은 예측 가능하다. 그러나, 만약 이러한 상황을 쉽게 예측할 수 없는 복잡하고 긴 코드를 작성한다고 가정했을 때, 자신도 모르게 기존에 사용하던 변수의 이름을 재사용하여 새로운 변수를 선언하는 일은 쉽게 일어날 수 있다. 뭔가 이상한 값이 반환되는데 그 원인을 찾지 못하는 꽤 심각한 상황을 불러올 수도 ..

#### 재할당

재할당은 사실 재선언만큼 큰 오류를 불러오진 않는다. let과 const의 차이는 변수는 let으로, 상수는 const로 선언한다고 이해하면 쉽다. 말 그대로, 스코프 내에서 값이 계속 변화하는 상황에서는 let을, 값이 변하는 상황이 발생하지 않을 예정이거나, 혹은 절대 변하면 안 되는 상황일 때 const를 사용한다. 

#### scope

스코프 : JS에서, 변수에 접근 가능한 범위

var은 함수 스코프, let과 const는 블록 스코프를 지니는데, 함수 스코프는 함수 내에서 접근 가능한 것, 블록 스코프는 중괄호에 묶인 범위 내에서만 접근 가능한 것을 뜻한다. 이를 코드로 살펴보면

```javascript
function temp() {
    if(){
        //변수 선언
    }
    // 변수 호출
}
```

위와 같은 상황에서 변수가 var로 선언되어 있다면, 변수의 선언과 호출이 속한 블록(중괄호)는 다르지만 temp라는 같은 함수 내에 있기 때문에 정상적으로 호출이 가능하다.

그러나 해당 변수가 블록 스코프를 지닌 let 또는 const로 선언되었을 경우, 변수가 선언되어 있는 if 문의 블록(중괄호) 밖에서 변수에 접근을 시도하고 있기에, 에러가 발생한다.

#### 호이스팅

호이스팅은 언급만 하고 넘어가셨는데 아주 간단하게만 설명을 해보자면 (깊게 파고들면 이것도 복잡하다) 변수 또는 (함수)에 대한 선언이 상단으로 이동하여 변수, 또는 함수에 대한 메모리 공간이 미리 할당되는 것인데, 이렇게만 들으면 무슨 말인가 싶을 수도 있으니 예시를 들어보자

```javascript
console.log(a); // undefined
var a = 1
```

위 코드를 살펴보면 뭔가 이상하게 생겼다. a라는 변수를 만들지도 않고 출력을 하려 시도를 하는데, let과 const로 선언된 변수는 이러한 상황에서 Reference errror가 발생하나, var로 생성된 변수는 에러가 발생하지 않으며 undefined가 출력된다. 그럴 수 있도록 해주는 것이 호이스팅인 것 ..

말 그대로 *var a = 1* 이라는 변수의 선언이 *console.log(a)* 라는 호출 코드의 상단으로 이동한다. 그러나, 이 때 선언과 값의 초기화를 별개로 보아야 한다.

```javascript
// var a = 1;

var a; // 선언
a = 1; // 초기화
```

해당 코드를 선언과 초기화로 분리하면 이렇게 되는데, 이 중 선언만 끌어올려지는 것. var은 변수의 선언과 초기화가 동시에 진행되기에, 호이스팅이 발생할 시 undefined 로 초기화가 진행된다(값은 없는 상태인데 메모리 공간이 존재함). 그렇기에 에러가 발생하지 않고 undefined 가 출력되는 것이다.

그러나 let 과 const는 선언과 초기화가 분리되어 진행되기에, 선언이 호이스팅 되면 초기화 되지 않은 변수가 전달되고, 이는 reference error을 발생시킨다. 

### function

코드를 먼저 살펴보면 아래와 같다

```javascript
// 함수 선언식
function hello(name){
    console.log(`안녕 ${name}`);
}

//함수 표현식  (화살표 함수)
const sum = (a, b) => {
    result = a + b;
    console.log(result);
}

const sum_ = (a,b) => a+b; // 위랑 같은 함수
```

JS에서 함수 표현식은 선언식과 표현식으로 나뉘는데 이 때 위에 호이스팅에서 또는 (함수) 라고 적어둔 부분에 대한 설명을 할 수 있다. 함수 선언식으로 선언한 함수에서는 호이스팅이 발생하며, 함수 표현식으로 작성한 함수에서는 호이스팅이 발생하지 않는다. 따라서 선언식의 경우, 아래와 같은 코드가 에러 없이 돌아가게 된다 (위험)

```javascript
// 함수 선언식
hello();
function hello(){
    console.log("안녕");
}
```


## TypeScript

JS에 타입 문법을 추가한 상위 집합으로, 코드 작성 시 타입을 체크하는 언어 (컴파일 언어, 정적 타입)

### type

#### 원시 타입

#### object

#### array

#### Object vs object

#### any


## Node.js

브라우저 밖에서 JS를 빌드할 수 있도록 해주는 환경으로 Chrome v8 javascript 엔진으로 빌드되어 있는 JS 런타임이다. 

### Single Thread vs Multi Thread

### Non-blocking I/O

### Event-driven